<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<rfc category='std' ipr='trust200902' docName='draft-ietf-oauth-00'>
  <?rfc strict='yes' ?>
  <?rfc toc='yes' ?>
  <?rfc tocdepth='3' ?>
  <?rfc symrefs='yes' ?>
  <?rfc sortrefs='yes' ?>
  <?rfc compact='yes' ?>
  <?rfc subcompact='no' ?>

  <front>
    
    <title abbrev='OAuth 2.0'>The OAuth 2.0 Protocol</title>

    <author fullname='Eran Hammer-Lahav' surname='Hammer-Lahav' initials='E' role='editor'>
      <organization />
      <address>
        <email>eran@hueniverse.com</email>
      </address>
    </author>
    <author fullname='David Recordon' surname='Recordon' initials='D'>
      <organization>Facebook</organization>
      <address>
        <email>davidrecordon@facebook.com</email>
        <uri>http://www.davidrecordon.com/</uri>
      </address>
    </author>
    <author fullname='Dick Hardt' surname='Hardt' initials='D'>
      <organization/>
      <address>
        <email>dick.hardt@gmail.com</email>
        <uri>http://dickhardt.org/</uri>
      </address>
    </author>

    <date year='2010' />

    <abstract>
      <t>
		OAuth provides a method for making authenticated HTTP requests using a token - an
        identifier used to denote an access grant with specific scope, duration, and other
        attributes. Tokens are issued to third-party clients by an authorization server with the
        approval of the resource owner. OAuth defines multiple flows for obtaining a token to
        support a wide range of client types and user experience.
      </t>
    </abstract>
  </front>

  <middle>
    <section title='Introduction'>
      <t>
        With the increasing use of distributed web services and cloud computing, third-party
        applications require access to server-hosted resources. These resources are usually
        private and require authentication using the resource owner's credentials (typically a
        username and password). In the traditional client-server authentication model, a client
        accessing a protected resource on a server presents the resource owner's credentials in
        order to authenticate and gain access.
      </t>
      <t>
        Resource owners should not be required to share their credentials when granting third-party
        applications access to their protected resources. They should also have the ability to
        restrict access to a limited subset of the resources they control, to limit access
        duration, or to limit access to the methods supported by these resources.
      </t>
      <t>
        OAuth provides a method for making authenticated HTTP requests using a token - an
        identifier used to denote an access grant with specific scope, duration, and other
        attributes. Tokens are issued to third-party clients by an authorization server with the
        approval of the resource owner. Instead of sharing their credentials with the client, resource
        owners grant access by authenticating directly with the authorization server which in turn
        issues a token to the client. The client uses the token to authenticate with the resource
        server and gain access.
      </t>
      <t>
        For example, a web user (resource owner) can grant a printing service (client) access to
        her private photos stored at a photo sharing service (resource server), without sharing her
        username and password with the printing service. Instead, she authenticates directly with
        the photo sharing service (authorization server) which issues the printing service
        delegation-specific credentials (token).
      </t>
      <t>
        The use of OAuth with any other transport protocol than <xref target='RFC2616'>HTTP</xref>
        is undefined.
      </t>

      <section title='Terminology'>
        <t>
          <list style='hanging' hangIndent='6'>
            <t hangText='resource server'>
              <vspace />
              An <xref target='RFC2616'>HTTP</xref> server capable of accepting authenticated
              resource requests using the OAuth protocol.
            </t>
            <t hangText='protected resource'>
              <vspace />
              An access-restricted resource which can be obtained from a resource server using
              an OAuth-authenticated request.
            </t>
            <t hangText='client'>
              <vspace />
              An HTTP client capable of making authenticated requests for protected resources using
              the OAuth protocol.
            </t>
            <t hangText='resource owner'>
              <vspace />
	          An entity capable of granting access to a protected resource.
            </t>
            <t hangText='end user'>
	          <vspace />
	          A human resource owner.
	        </t>
            <t hangText='access token'>
              <vspace />
              A unique identifier used by the client to make authenticated requests on behalf of
              the resource owner. Access tokens may have a matching secret.
            </t>
            <t hangText='authorization server'>
              <vspace />
              An HTTP server capable of issuing tokens after successfully authenticating the
              resource owner and obtaining authorization. The authorization server may be the same
              server as the resource server, or a separate entity.
            </t>
            <t hangText='authorization endpoint'>
              <vspace />
              The authorization server's HTTP endpoint authenticating the resource owner, obtaining
              authorization, issuing tokens, and refreshing expired tokens.
            </t>
            <t hangText='client identifier'>
              <vspace />
              An unique identifier issued by the client to identify itself to the authorization
              server. Client identifiers may have a matching secret.
            </t>
            <t hangText='refresh token'>
              <vspace />
              A unique identifier used by the client to replace an expired access token with a new
              access token without having to involve the resource owner. A refresh token is used
              when the access token is valid for a shorter time period than the duration of the
              access grant approved by the resource owner.
            </t>
          </list>
        </t>
      </section>

	  <section title='Overview'>
	    <t>
		  Clients interact with a protected resource, first by requesting access (which is granted
		  in the form of an access token) from the authorization server, and then by authenticating
		  with the resource server by presenting the access token. <xref target='Figure 1' />
		  demonstrates the flow between the client and authorization server (A, B), and the flow
		  between the client and resource server (C, D), when the client is acting autonomously
		  (the client is also the resource owner).
	    </t>
        <figure anchor='Figure 1'>
	      <artwork><![CDATA[
  +---+                                  +---------------+
  |   |--(A)------ Credentials --------->| Authorization |
  | C |                                  |    Server     |
  | l |<-(B)------ Access Token ---------|               |
  | i |      (w/ Optional Refresh Token) +---------------+
  | e |
  | n |            HTTP Request          +---------------+
  | t |--(C)--- with Access Token ------>|    Resource   |
  |   |                                  |     Server    |
  |   |<-(D)------ HTTP Response --------|               |
  +---+                                  +---------------+
]]>
          </artwork>
        </figure>
        <t>
		  Access token strings can use any internal structure agreed upon between the authorization
		  server and the resource server, but their structure is opaque to the client. Since the
		  access token provides the client access to the protected resource for the life of the
		  access token, the authorization server should issue access tokens which expire within an
		  appropriate time, usually much shorter than the duration of the access grant.
		</t>
		<t>
	      When an access token expires, the client can request a new access token from the
	      authorization server by presenting its credentials again (<xref target='Figure 1' />), or
	      by using the refresh token (if issued with the access token) as shown in
	      <xref target='Figure 2' />. Once an expired access token has been replaced with a new
	      access token (A, B), the client uses the new access token as before (C, D).
	    </t>
        <figure anchor='Figure 2'>
		   <artwork><![CDATA[
  +---+                                  +---------------+
  |   |--(A)------ Refresh Token ------->| Authorization |
  | C |                                  |    Server     |
  | l |<-(B)------ Access Token ---------|               |
  | i |                                  +---------------+
  | e |
  | n |            HTTP Request          +---------------+
  | t |--(C)--- with Access Token ------>|    Resource   |
  |   |                                  |     Server    |
  |   |<-(D)----- HTTP Response ---------|               |
  +---+                                  +---------------+
]]>
		  </artwork>
		</figure>
		<t>
	      This specification defines a number of authorization flows to support different client
	      types and scenarios. These authorization flows can be separated into three groups:
	      user delegation flows where the client is acting on behalf of an end user, end user
	      credentials flows where the client uses the end user's credentials directly to obtain
	      authorization, and autonomous flows where the client is acting for itself (the client is
	      also the resource owner).
	    </t>
	    <t>
	      Additional authorization flows may be defined by other specifications to cover different
	      scenarios and client types.
        </t>
	    <t>
		  The user delegation authorization flows defined by this specifications are:

		  <list style='hanging' hangIndent='6'>
			<t hangText='Web Callback Flow'>
              <vspace />
              This flow is described in <xref target='web_callback_flow' />.
		    </t>
			<t hangText='Web Client Flow'>
              <vspace />
              This flow is described in <xref target='web_client_flow' />.
		    </t>
			<t hangText='Device Flow'>
              <vspace />
              This flow is described in <xref target='device_flow' />.
		    </t>
		  </list>
		</t>
		<t>
	      The end user credentials flow defined by this specification is:
	
	      <list style='hanging' hangIndent='6'>
			<t hangText='Username and Password Flow'>
              <vspace />
			  While the User may use a username and password to authenticate to the
	          Authorization Server, it is undesirable for the Client to store the
	          User's username and password. In this flow the User provides their
	          username and password to an application (Client) they have installed
	          on their device. The Client presents a Client Identifier, the username
	          and password (credentials) to the Access Token URI at the
	          Authorization Server in exchange for an Access Token and a Refresh
	          Token. This flow is described in <xref target='username_password_flow' />.
		    </t>
	      </list>
	    </t>
        <t>
	      The autonomous authorization flows defined by this specifications are:
	
	      <list style='hanging' hangIndent='6'>
		    <t hangText='Client Credentials Flow'>
              <vspace />
			  The client is provisioned with an account name and corresponding secret by the
			  authorization server. The client presents the account name and secret to the
			  authorization Server in exchange for an access token. The client secret is assumed to
			  be high-entropy since it is not designed to be memorize by an end user. This flow is
			  described in <xref target='client_credentials_flow' />.
			</t>
		    <t hangText='SAML Assertion Flow'>
              <vspace />
			  The client presents a <xref target="OASIS.saml-core-2.0-os">SAML</xref> assertion to
			  the authorization server in exchange for an access token. The methods through which
			  the client obtains the assertions are beyond the scope of this specification. This
			  flow is described in <xref target='saml_assertion_flow' />.
			</t>
		  </list>
		</t>
	  </section>

      <section title='Example'>
        <t>
          [[ Todo ]]
        </t>
      </section>

      <section title='Notational Conventions'>
        <t>
          The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD', 'SHOULD
          NOT', 'RECOMMENDED', 'MAY', and 'OPTIONAL' in this document are to be interpreted as
          described in <xref target='RFC2119' />.
        </t>
        <t>
          This document uses the Augmented Backus-Naur Form (ABNF) notation of
          <xref target="I-D.ietf-httpbis-p1-messaging" />. Additionally, the realm and auth-param
          rules are included from <xref target="RFC2617" />, and the URI-Reference rule from
          <xref target="RFC3986" />.
        </t>
      </section>

      <section title='Authors'>
	    <t>
		  This specification was authored with the participation and based on the work of
		  Allen Tom, Brian Eaton, Brent Goldman, Luke Shepard, Raffi Krikorian, and Yaron Goland.
		</t>
	  </section>

    </section>

    <section title='Obtaining an Access Token' anchor='get_token'>
      <t>
        The client obtains an access token by using one of the authorization flows supported by the
        authorization server. The authorization flows all use the same authorization endpoint, each
        with a different set of request parameters and values.
      </t>

      <section title='Authorization Endpoint'>
        <t>
          The client obtains the URI of the authorization endpoint from the server's documentation,
          or by making an unauthorized protected resource request (from the
          <spanx style='verb'>WWW-Authenticate</spanx> response header
          <xref target='authz_uri_attribute'>authorization-uri</xref> attribute).
        </t>
        <t>
          The authorization endpoint advertised by the server MUST NOT include a query or fragment
          components as defined by <xref target='RFC3986' /> section 3.
        </t>
      </section>

      <section title='Flow Parameters'>
        <t>
          Clients should avoid making assumptions about the size of tokens and other server-generated
          values, which are left undefined by this specification. Servers should document the
          expected size of any value they issue.
        </t>
        <t>
	      [[ Open Issue ]]
	      It is RECOMMENDED that authorization servers make their identifiers, secrets, and tokens
	      string shorter than 255 characters in length in order to ease client implementations.
        </t>
        <t>
          The values of the request and response parameters defined in this section MUST only contain
          the following characters:
        </t>
        <figure>
	      <artwork><![CDATA[
  value-char  = ALPHA / DIGIT / "-" / "." / "_" / "~" / "%"
]]>
          </artwork>
        </figure>
        <t>
	      Servers which require the use of other characters MUST specify how such values are to be
	      encoded to comply with the character-set restriction.
	    </t>
      </section>

      <section title='Client Credentials'>
	    <t>
		  When requesting access from the authorization server, the client identifies itself using
		  its authorization-server-issued client credentials. The client credentials include a
		  client identifier and an optional symmetric shared secret. The means through which the
		  client obtains these credentials are beyond the scope of this specification, but usually
		  involve registration with the authorization server.
		</t>
		<t>
	      The client identifier is used by the authorization server to establish the identity of
	      the client for the purpose of presenting information to the resource owner prior to
	      granting access, as well as for providing different service levels to different clients.
	      They can also be used to block unauthorized clients from requesting access.
	    </t>
	    <t>
		  Due to the nature of some clients, authorization servers SHOULD NOT make assumptions
		  about the confidentiality of client credentials without establishing trust with the
		  client operator. 
		</t>
	  </section>

      <section title='User Delegation Flows'>
	    <t>
		  User delegation flows are used to grant client access to protected resources by the
		  end user without sharing the end user credentials (typically a username and password)
		  with the client. Instead, the end user authenticates directly with the authorization
		  server, and grants client access to its protected resources.
		</t>
		
        <section title='Web Callback Flow' anchor='web_callback_flow'>
          <t>
            The web callback flow is a user delegation flow suitable for clients capable of
            interacting with the end user's user-agent (typically a web browser) and capable of
            receiving callback requests from the server.
          </t>
		  <figure anchor='Figure 3'>
		    <artwork><![CDATA[
  +---------+ 
  | Web App |
  | Client  |
  +---------+
    v    ^
	|    |
   (A)  (C)
    |    |
	\    \
  +---------+                                 +---------------+
  |         |\---(C)-- Verification Code ----<|               |
  |   User  |                                 | Authorization |
  |    at   |<---(B)-- User authenticates --->| Server        |
  | Browser |                                 |               |
  |         |\---(A)-- Client Identifier ---->|               |
  +---------+                                 +---------------+
]]>
            </artwork>
		  </figure>
          <t>
            The client MUST first send the resource owner's user-agent (commonly his or her
            web browser) to the authorization server's user authorization request endpoint.
            The client constructs the request URI by adding the following REQUIRED query
            parameters to the user authorization endpoint URI:

            <list style='hanging' hangIndent='6'>
              <t hangText='mode'>
	            <vspace />
                The parameter value MUST be set to 'flow_web_server' (case sensitive).
              </t>
              <t hangText='client_id'>
	            <vspace />
                The client identifier.
              </t>
              <t hangText='callback_uri'>
	            <vspace />
                An absolute URI to which the authorization server will redirect the end user back
                when the end user authorization step is completed. The authorization server MAY
                require the client to pre-register their callback URI.
              </t>
            </list>
          </t>
          <t>
            The client MAY also include the following OPTIONAL parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='client_state'>
	            <vspace />
                An opaque value that clients can use to maintain state associated with
                this request.
              </t>
              <t hangText='scope'>
	            <vspace />
                If the authorization server has defined a manner for the client to
                request certain capabilities of the access token, this parameter SHOULD
                be used to do so.
              </t>
            </list>
          </t>
          <t>
            The client directs the resource owner to the constructed URI using an HTTP
            redirection response, or by other means available to it via the resource
            owner's user-agent. The request MUST use the HTTP 'GET' method.
          </t>
          <figure>
            <preamble>
              For example, the client directs the resource owner's user-agent to make the
              following HTTPS requests (line breaks are for display purposes only):
            </preamble>
            <artwork><![CDATA[
  GET /user_authorization?mode=flow_web_server&client_id=s6BhdRkqt3&c
      allback_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
  Host: server.example.com
]]>
            </artwork>
          </figure>
          <t>
            The way in which the server handles the user authorization request (such as via
            cookies), including whether it uses a secure channel such as TLS/SSL is beyond
            the scope of this specification. However, the server MUST first verify the
            identity of the resource owner. If the resource owner approves the
            authorization request, the authorization server MUST generate a verification
            code and associate it with the client identifier and callback URI.
          </t>
          <t>
            After receiving an authorization decision from the resource owner, the server
            redirects the resource owner to the callback URI if one was provided in the
            'callback' parameter or pre-registered by other means. The authorization
            server constructs the request URI by adding one of the two following REQUIRED
            parameters to the callback URI query component depending on if the resource
            owner approved (verification_code) or declined (error_reason) the
            authorization request:

            <list style='hanging' hangIndent='6'>
              <t hangText='verification_code'>
	            <vspace />
                The verification code.
              </t>
              <t hangText='error_reason'>
	            <vspace />
                The parameter value MUST be set to 'owner_denied' (case sensitive).
              </t>
            </list>
          </t>
          <t>
            The authorization server MAY also include the following parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='client_state'>
	            <vspace />
                REQUIRED if the client sent the parameter in its request.
              </t>
            </list>
          </t>
          <t>
            If the callback URI already includes a query component as defined by
            <xref target='RFC3986' /> section 3, the server MUST append the OAuth
            parameters to the end of the existing query. The callback URI's query component
            MUST NOT contain any parameters beginning with the '' prefix.
          </t>
          <figure>
            <preamble>
              For example, the server redirects the resource owner's user-agent:
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 302 Found
  Location: https://client.example.com/cb?verification_code=i1WsRn1uB1
]]>
            </artwork>
          </figure>
          <figure>
            <preamble>
              Continuing the example, this results in the resource owner's user-agent
              making the following HTTPS 'GET' request:
            </preamble>
            <artwork><![CDATA[
  GET /cb?verification_code=i1WsRn1uB1 HTTP/1.1
  Host: client.example.com
]]>
            </artwork>
          </figure>
          <figure>
            <artwork><![CDATA[
  GET /cb?error_reason=owner_denied HTTP/1.1
  Host: client.example.com
]]>
            </artwork>
          </figure>
          <t>
            If the client receives a verification code, it constructs an HTTP 'POST'
            request to the access token request endpoint and includes the following
            REQUIRED parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='mode'>
	            <vspace />
                The parameter value MUST be set to 'flow_web_app' (case sensitive).
              </t>
              <t hangText='client_id'>
	            <vspace />
                The client identifier.
              </t>
              <t hangText='client_secret'>
	            <vspace />
                The client secret.
              </t>
              <t hangText='verification_code'>
	            <vspace />
                The verification code.
              </t>
              <t hangText='callback_uri'>
	            <vspace />
                The callback URI from the user authorization request.
              </t>
            </list>
          </t>
          <t>
            Since the request results in the transmission of plain text credentials in the
            HTTP request and response, the authorization server MUST require the use of a
            transport-layer mechanism such as TLS or SSL (or a secure channel with
            equivalent protections).
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request (line breaks are for display
              purposes only):
            </preamble>
            <artwork><![CDATA[
  POST /access_token HTTP/1.1
  Host: server.example.com

  client_id=s6BhdRkqt3&client_secret=gX1fBat3bV&verification_code=i1WsR
  n1uB1&callback_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]>
            </artwork>
          </figure>
          <t>
            If the request is authorized, the access token is included in the HTTP response
            body using the 'application/x-www-form-urlencoded' content type as defined by
            <xref target='W3C.REC-html40-19980424' /> with a 200 status code (OK). The
            response contains the following REQUIRED parameter:

            <list style='hanging' hangIndent='6'>
              <t hangText='access_token'>
	            <vspace />
                The access token.
              </t>
            </list>
          </t>
          <t>
            The authorization server MAY also include the following parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='expires'>
	            <vspace />
                The lifetime of the access token in seconds.
              </t>
              <t hangText='refresh_token'>
	            <vspace />
                The refresh token.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/x-www-form-urlencoded

  access_token=SlAV32hkKG&refresh_token=8xLOxBtZp8
]]>
            </artwork>
          </figure>
          <t>
            The authorization server must retain the scope, duration, and other attributes
            approved by the resource owner, and enforce these restrictions when receiving a
            client request made with the tokens issued.
          </t>
          <t>
            Once the client receives and stores the token credentials, it can proceed to
            access protected resources on behalf of the resource owner by making
            authenticated requests (<xref target='access_resource' />) using the access
            token received. Alternatively, it can refresh the access token and request an
            access secret to use in the signature flow (<xref target='refresh_token' />).
          </t>
          <t>
            If the authorization server is unable to issue an access token to the client,
            the HTTP response body uses the 'application/x-www-form-urlencoded' content
            type as defined by <xref target='W3C.REC-html40-19980424' /> with a 401 status
            code (Unauthorized). The response contains the following OPTIONAL parameter:

            <list style='hanging' hangIndent='6'>
              <t hangText='error_reason'>
	            <vspace />
                Value must be one of 'callback_uri_mismatch' or
                'expired_verification_code' (case sensitive).
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 401 Authorization Required
  WWW-Authenticate: OAuth realm='example'

  error_reason=expired_verification_code
]]>
            </artwork>
          </figure>
        </section>

        <section title='Web Client Flow' anchor='web_client_flow'>
          <t>
            The Web Client Flow is similar to the <xref target='web_callback_flow'>Web Callback Flow</xref>,
            but it has different security characteristics. Client-side applications are
            those that live entirely in JavaScript, on the desktop, on a mobile device,
            or in other environments where the code does not have easy access to a server.
            These applications have the ability to display a web page to the user, but
            cannot receive the response on a server. Because the entirety of the client is
            downloaded to the resource owner's user-agent, it is not possible to completely
            protect the client secret. This flow allows for authorization while taking
            those security considerations into account.
          </t>
          <t>
            Because there is no client secret to ensure authenticity, both the client and
            authorization server should take some extra precautions when using this flow.
            Specifically, as the access token flows directly to the user-agent, it should
            only be used when it is acceptable for the end-user to have direct access to
            the access token. Additionally, care should be taken to choose a good callback
            URI, as described below.
          </t>
          <t>
            The authorization server SHOULD require the client to
            pre-register their callback URI.
          </t>
          <t>
            The client MUST first send the resource owner's user-agent to the authorization
            server's user authorization request endpoint. The client constructs the request
            URI by adding the following REQUIRED query parameters to the user authorization
            endpoint URI:

            <list style='hanging' hangIndent='6'>
              <t hangText='mode'>
	            <vspace />
                The parameter value MUST be set to 'flow_web_client' (case sensitive).
              </t>
              <t hangText='client_id'>
	            <vspace />
                The client identifier.
              </t>
              <t hangText='callback_uri'>
	            <vspace />
                An absolute URI to which the authorization server will redirect the
                resource owner back when the authorization step is completed. The
                client MUST make use of at least one of either a transport-layer
                mechanism such as TLS or SSL (or a secure channel with equivalent
                protections) for the callback URI or including a fragment identifier
                ('#') as defined by <xref target='RFC3986' /> section 3.5 in the URI to
                prevent transmission of plain text credentials.
              </t>
            </list>
          </t>
          <t>
            The client MAY also include the following OPTIONAL parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='client_state'>
	            <vspace />
                An opaque value that clients can use to maintain state associated with
                this request.
              </t>
              <t hangText='scope'>
	            <vspace />
                If the authorization server has defined a manner for the client to
                request certain capabilities of the access token, this parameter SHOULD
                be used to do so.
              </t>
            </list>
          </t>
          <t>
            The client directs the resource owner to the constructed URI using an HTTP
            redirection response, or by other means available to it via the resource
            owner's user-agent. The request MUST use the HTTP 'GET' method.
          </t>
          <figure>
            <preamble>
              For example, the client directs the resource owner's user-agent to make one
              of the following HTTPS requests (line breaks are for display purposes only):
            </preamble>
            <artwork><![CDATA[
  GET /user_authorization?mode=flow_web_client&client_id=s6BhdRkqt3&c
      allback_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
  Host: server.example.com
]]>
            </artwork>
          </figure>
          <figure>
            <artwork><![CDATA[
  GET /user_authorization?mode=flow_web_client&client_id=s6BhdRkqt3&c
      allback_uri=http%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb# HTTP/1.1
  Host: server.example.com
]]>
            </artwork>
          </figure>
          <t>
            The way in which the server handles the user authorization request (such as via
            cookies), including whether it uses a secure channel such as TLS/SSL is beyond
            the scope of this specification. However, the server MUST first verify the
            identity of the resource owner.
          </t>
          <t>
            If the Client has previously registered a callback URI with the authorization
            server, it MUST verify that the callback URI provided in the 'callback'
            parameter is valid given the pre-registered URI.
          </t>
          <t>
            After receiving an authorization decision from the resource owner, the server
            redirects the resource owner to the callback URI. The authorization server
            constructs the request URI by adding the following REQUIRED parameter to the
            callback URI query component:

            <list style='hanging' hangIndent='6'>
              <t hangText='access_token'>
	            <vspace />
                The access token.
              </t>
            </list>
          </t>
          <t>
            The authorization server MAY also include the following parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='expires'>
	            <vspace />
                The lifetime of the access token in seconds.
              </t>
              <t hangText='refresh_token'>
	            <vspace />
                The refresh token.
              </t>
            </list>
          </t>
          <t>
            If the callback URI already includes a query component as defined by
            <xref target='RFC3986' /> section 3, the server MUST append the OAuth
            parameters to the end of the existing query. If the callback URI includes a
            fragment (#), then the OAuth parameters MUST be appended to the end of the
            query, after the fragment. The callback URI's query component MUST NOT contain
            any parameters beginning with the '' prefix.
          </t>
          <figure>
            <preamble>
              For example, the server redirects the resource owner's user-agent:
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 302 Found
  Location: https://example.com/cb?access_token=FJQbwq9OD&expires=10800
]]>
            </artwork>
          </figure>
          <figure>
            <artwork><![CDATA[
   HTTP/1.1 302 Found
   Location: http://example.com/cb#access_token=FJQbwq9OD&expires=10800
]]>
            </artwork>
          </figure>
          <figure>
            <preamble>
              Continuing the example, this results in the resource owner's user-agent to
              make the following HTTPS/HTTP 'GET' request:
            </preamble>
            <artwork><![CDATA[
  GET /cb?access_token=FJQbwq9OD8&expires=10800 HTTP/1.1
  Host: client.example.com
]]>
            </artwork>
          </figure>
          <figure>
            <artwork><![CDATA[
  GET /cb#?access_token=FJQbwq9OD8&expires=10800 HTTP/1.1
  Host: client.example.com
]]>
            </artwork>
          </figure>
          <t>
            The authorization server must retain the scope, duration, and other attributes
            approved by the resource owner, and enforce these restrictions when receiving a
            client request made with the tokens issued.
          </t>
          <t>
            Once the client receives and stores the token credentials, it can proceed to
            access protected resources on behalf of the resource owner by making
            authenticated requests (<xref target='access_resource' />) using the access
            token received. Alternatively, it can refresh the access token and request an
            access secret to use in the signature flow (<xref target='refresh_token' />).
          </t>
          <t>
            If the request fails verification, the authorization server SHOULD respond with
            the appropriate HTTP response status code. The authorization server MAY include
            further details about why the request was rejected in the response body.
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 401 Authorization Required
  WWW-Authenticate: OAuth realm='example'
]]>
            </artwork>
          </figure>
        </section>

        <section title='Device Flow' anchor='device_flow'>
          <t>
            The Device Flow is suitable when the client is a device which does not have an
            easy data-entry method (e.g. game consoles or entertainment centers), but where
            the end-user has access to a separate computer with simple data-entry methods
            (e.g. their home computer, a laptop or a smartphone).
          </t>
          <t>
            Prior to making a request using this flow, the client MUST have obtained a
            client identifier and access token request endpoint URI from the authorization
            server.
          </t>
          <t>
            The client constructs an HTTP 'GET' request to the access token request
            endpoint and includes the following REQUIRED parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='mode'>
	            <vspace />
                The parameter value MUST be set to 'flow_device' (case sensitive).
              </t>
              <t hangText='client_id'>
	            <vspace />
                The client identifier.
              </t>
            </list>
          </t>
          <t>
            The client MAY also include the following OPTIONAL parameters as well as any
            additional parameters as defined by the authorization server:

            <list style='hanging' hangIndent='6'>
              <t hangText='scope'>
	            <vspace />
                If the authorization server has defined a manner for the client to
                request certain capabilities of the access token, this parameter SHOULD
                be used to do so.
              </t>
            </list>
          </t>
          <t>
            Since the request results in the transmission of temporary plain text
            credentials in the HTTP response, the authorization server MUST require the use
            of a transport-layer mechanism such as TLS or SSL (or a secure channel with
            equivalent protections).
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request:
            </preamble>
            <artwork><![CDATA[
  GET /access_token?client_id=s6BhdRkqt3&mode=flow_device HTTP/1.1
  Host: server.example.com
]]>
            </artwork>
          </figure>
          <t>
            Upon receiving an authorization request by the client, the authorization server
            generates a device verification code and a user verification code. These are
            included in the HTTP response body using the
            'application/x-www-form-urlencoded' content type as defined by
            <xref target='W3C.REC-html40-19980424' /> with a 200 status code (OK). The
            response contains the following REQUIRED parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='device_code'>
	            <vspace />
                The device verification code.
              </t>
              <t hangText='user_code'>
	            <vspace />
                The user verification code.
              </t>
              <t hangText='verification_uri'>
	            <vspace />
                The user verification URI on the authorization server.
              </t>
            </list>
          </t>
          <t>
            The authorization server MAY also include the following parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='expires'>
	            <vspace />
                The lifetime of the two verification codes in seconds.
              </t>
              <t hangText='verification_rate_limit'>
	            <vspace />
                The minimum amount of time in seconds that the client SHOULD wait
                between polling requests to the device authorization URI.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example (line breaks are for display purposes only):
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/x-www-form-urlencoded

  device_code=74tq5miHKB&user_code=94248&verification_uri=http%3A%2F%2
  Fwww%2Eexample%2Ecom%2Fdevice&verification_rate_limit=3
]]>
            </artwork>
          </figure>
          <t>
            The client MUST display the user verification URI and the user verification
            code to the end-user, instruct them to visit the user verification URI in a web
            browser, and to enter the user verification token upon doing so (a user
            authorization request).
          </t>
          <t>
            The way in which the authorization server handles the user authorization
            request, including whether it uses a secure channel such as TLS/SSL is beyond
            the scope of this specification. However, the server MUST first verify the
            identity of the resource owner. After doing so, the server MUST prompt the
            end-user to enter the user verification code.
          </t>
          <t>
            The authorization server MUST verify that the user verification code is valid
            and MAY verify that the client is authorized to use this flow. If the request
            is authorized, the authorization server directs the end-user to go back to the
            client device and follow its instructions.
          </t>
          <t>
            The client MAY have an interface element (such as a button) that the end-user
            interacts with to communicate that they have finished the authorization
            process. The client MAY initiate the following request at an arbitrary but
            reasonable interval in order to create a more responsive user experience though
            MUST NOT exceed the verification rate limit if one is specified. The client
            MUST either poll or have an interface element, or both.
          </t>
          <t>
            The client constructs an HTTP 'GET' request to the access token request
            endpoint and includes the following REQUIRED parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='mode'>
	            <vspace />
                The parameter value MUST be set to 'flow_device' (case sensitive).
              </t>
              <t hangText='client_id'>
	            <vspace />
                The client identifier.
              </t>
              <t hangText='device_verification_code'>
	            <vspace />
                The device verification code.
              </t>
            </list>
          </t>
          <t>
            Since the request results in the transmission of plain text credentials in the
            HTTP response, the authorization server MUST require the use of a
            transport-layer mechanism such as TLS or SSL (or a secure channel with
            equivalent protections).
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request (line breaks are for display
              purposes only):
            </preamble>
            <artwork><![CDATA[
  GET /access_token?client_id=s6BhdRkqt3&device_verification_code=J2v
      C42OifV HTTP/1.1
  Host: server.example.com
]]>
            </artwork>
          </figure>
          <t>
            If the request is authorized, the access token is included in the HTTP response
            body using the 'application/x-www-form-urlencoded' content type as defined by
            <xref target='W3C.REC-html40-19980424' /> with a 200 status code (OK). The
            response contains the following REQUIRED parameter:

            <list style='hanging' hangIndent='6'>
              <t hangText='access_token'>
	            <vspace />
                The access token.
              </t>
            </list>
          </t>
          <t>
            The authorization server MAY also include the following parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='expires'>
	            <vspace />
                The lifetime of the access token in seconds.
              </t>
              <t hangText='refresh_token'>
	            <vspace />
                The refresh token.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/x-www-form-urlencoded

  access_token=FJQbwq9OD8&expires=600
]]>
            </artwork>
          </figure>
          <t>
            The authorization server must retain the scope, duration, and other attributes
            approved by the resource owner, and enforce these restrictions when receiving a
            client request made with the tokens issued.
          </t>
          <t>
            Once the client receives and stores the token credentials, it can proceed to
            access protected resources on behalf of the resource owner by making
            authenticated requests (<xref target='access_resource' />) using the access
            token received. Alternatively, it can refresh the access token and request an
            access secret to use in the signature flow (<xref target='refresh_token' />).
          </t>
          <t>
            If the authorization server is unable to issue an access token to the client,
            the HTTP response body uses the 'application/x-www-form-urlencoded' content
            type as defined by <xref target='W3C.REC-html40-19980424' /> with a 401 status
            code (Unauthorized). The response contains the following REQUIRED parameter:

            <list style='hanging' hangIndent='6'>
              <t hangText='error_reason'>
	            <vspace />
                Value must be one of 'authorization_declined', 'authorization_pending',
                'slow_down', or 'verification_code_expired' (case sensitive).
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 401 Authorization Required
  WWW-Authenticate: OAuth realm='example'

  error_reason=authorization_pending
]]>
            </artwork>
          </figure>
        </section>

      </section>

      <section title='End User Credentials Flows'>
	    <t>
		</t>

        <section title='Username and Password Flow' anchor='username_password_flow'>
          <t>
            This flow is used when the authorization server generally trusts the client to
            temporarily collect the end-user's username and password and it is impossible
            to use one of the other authorization flows. This flow enables a client to act
            on behalf of the resource owner without having to permanently store their
            username and password. This flow also enables clients who previously used
            username and password to perform a conversion to token based credentials.
          </t>
          <t>
            Prior to making a request using this flow, the client MUST have obtained a
            client identifier and access token request endpoint URI from the authorization
            server. How the client prompts the resource owner for their username and
            password is beyond the scope of this specification. The client must discard the
            resource owner's username and password once an access token has been obtained.
          </t>
          <t>
            Because the end-user's username and password flows through the client, it is
            RECOMMENDED that authorization servers only allow 'trusted' clients to have
            access to this flow; it is RECOMMENDED that, by default, a client does not have
            access to this flow, and it must have its abilities elevated somehow. In the
            case of allowing a client to convert usernames and passwords to tokens, it is
            RECOMMENDED that a client only be given access to this flow for a set time
            duration. The method by which to elevate permissions is out of scope for this
            document.
          </t>
          <t>
            The client constructs an HTTP 'POST' request to the access token request
            endpoint and includes the following REQUIRED parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='mode'>
	            <vspace />
                The parameter value MUST be set to 'flow_username_password' (case sensitive).
              </t>
              <t hangText='client_id'>
	            <vspace />
                The client identifier.
              </t>
              <t hangText='username'>
 	            <vspace />
                The resource owner's username.
              </t>
              <t hangText='password'>
	            <vspace />
                The resource owner's password.
              </t>
            </list>
          </t>
          <t>
            The client MAY also include the following OPTIONAL parameters as well as any
            additional parameters as defined by the authorization server:

            <list style='hanging' hangIndent='6'>
              <t hangText='scope'>
	            <vspace />
                If the authorization server has defined a manner for the client to
                request certain capabilities of the access token, this parameter SHOULD
                be used to do so.
              </t>
            </list>
          </t>
          <t>
            Since the request results in the transmission of plain text credentials in both
            the HTTP request and response, the authorization server MUST require the use of
            a transport-layer mechanism such as TLS or SSL (or a secure channel with
            equivalent protections).
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request (line breaks are for display
              purposes only):
            </preamble>
            <artwork><![CDATA[
  POST /access_token HTTP/1.1
  Host: server.example.com
  
  client_id=s6BhdRkqt3&username=daveman692&password=1password&mode=flow
  _username_password
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST verify that the resource owner's credentials are
            accurate and MAY verify that the client is authorized to use this flow. If the
            request is authorized, the access token is included in the HTTP response body
            using the 'application/x-www-form-urlencoded' content type as defined by
            <xref target='W3C.REC-html40-19980424' /> with a 200 status code (OK).
          </t>
          <t>
            The response contains the following REQUIRED parameter:

            <list style='hanging' hangIndent='6'>
              <t hangText='access_token'>
	            <vspace />
                The access token.
              </t>
            </list>
          </t>
          <t>
            The authorization server MAY also include the following parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='expires'>
	            <vspace />
                The lifetime of the access token in seconds.
              </t>
              <t hangText='refresh_token'>
	            <vspace />
                The refresh token.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/x-www-form-urlencoded

  access_token=FJQbwq9OD8&refresh_token=gO3CHNqpH8
]]>
            </artwork>
          </figure>
          <t>
            The authorization server must retain the scope, duration, and other attributes approved
            by the resource owner, and enforce these restrictions when receiving a client request
            made with the tokens issued.
          </t>
          <t>
            Once the client receives and stores the token credentials, it can proceed to access
            protected resources on behalf of the resource owner by making authenticated requests
            (<xref target='access_resource' />) using the access token received. Alternatively, it
            can refresh the access token and request an access secret to use in the signature flow
            (<xref target='refresh_token' />).
          </t>
          <t>
            If the request fails verification, the authorization server SHOULD respond with the
            appropriate HTTP response status code. The authorization server MAY include further
            details about why the request was rejected in the response body.
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 401 Authorization Required
  WWW-Authenticate: OAuth realm='example'
]]>
            </artwork>
          </figure>
        </section>

      </section>

      <section title='Autonomous Client Flows'>
	    <t>
		</t>

        <section title='Client Credentials Flow' anchor='client_credentials_flow'>
          <t>
            This flow is suitable when the client acts autonomously in seeking access and is thus not
            accessing protected resources within the context of a given end-user. For example, when a
            client is accessing non-private data or modifying data about itself. This flow SHOULD NOT
            be used when the client is acting on behalf of an end-user.
          </t>
          <t>
            Prior to making a request using this flow, the client MUST have obtained a client
            identifier, client secret, and access token request endpoint URI from the
            authorization server.
          </t>
          <t>
            The client constructs an HTTP 'POST' request to the access token request endpoint and
            includes the following REQUIRED parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='mode'>
	            <vspace />
                The parameter value MUST be set to 'flow_client' (case sensitive).
              </t>
              <t hangText='client_id'>
	            <vspace />
                The client identifier.
              </t>
              <t hangText='client_secret'>
	            <vspace />
                The client secret.
              </t>
            </list>
          </t>
          <t>
            The client MAY also include the following OPTIONAL parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='scope'>
	            <vspace />
                If the authorization server has defined a manner for the client to request certain
                capabilities of the access token, this parameter SHOULD be used to do so.
              </t>
            </list>
          </t>
          <t>
            Since the request results in the transmission of plain text credentials in both the HTTP
            request and response, the authorization server MUST require the use of a transport-layer
            mechanism such as TLS or SSL (or a secure channel with equivalent protections).
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request:
            </preamble>
            <artwork><![CDATA[
  POST /access_token HTTP/1.1
  Host: server.example.com
  
  client_id=s6BhdRkqt3&client_secret=8eSEIpnqmM&mode=flow_client
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST verify that the resource owner has authorized the
            provisioning of an access token to the client. If the request is authorized, the access
            token is included in the HTTP response body using the 'application/x-www-form-urlencoded'
            content type as defined by <xref target='W3C.REC-html40-19980424' /> with a 200 status
            code (OK).
          </t>
          <t>
            The response contains the following REQUIRED parameter:

            <list style='hanging' hangIndent='6'>
              <t hangText='access_token'>
	            <vspace />
                The access token.
              </t>
            </list>
          </t>
          <t>
            The authorization server MAY also include the following parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='expires'>
	            <vspace />
                The lifetime of the access token in seconds.
              </t>
              <t hangText='refresh_token'>
	            <vspace />
                The refresh token.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/x-www-form-urlencoded

  access_token=FJQbwq9OD8&refresh_token=gO3CHNqpH8
]]>
            </artwork>
          </figure>
          <t>
            The authorization server must retain the scope, duration, and other attributes approved
            by the resource owner, and enforce these restrictions when receiving a client request
            made with the tokens issued.
          </t>
          <t>
            Once the client receives and stores the token credentials, it can proceed to access
            protected resources on behalf of the resource owner by making authenticated requests
            (<xref target='access_resource' />) using the access token received. Alternatively, it
            can refresh the access token and request an access secret to use in the signature flow
            (<xref target='refresh_token' />).
          </t>
          <t>
            If the request fails verification, the authorization server SHOULD respond with the
            appropriate HTTP response status code. The authorization server MAY include further
            details about why the request was rejected in the response body.
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork><![CDATA[
  HTTP/1.1 401 Authorization Required
  WWW-Authenticate: OAuth realm='example'
]]>
            </artwork>
          </figure>
        </section>

        <section title="SAML Assertion Flow" anchor='saml_assertion_flow'>
          <t>
	        The SAML assertion flow requires the client to obtain a
	        <xref target="OASIS.saml-core-2.0-os">SAML</xref> assertion from an assertion issuer
	        prior to initiating this flow. The process in which the assertion is obtained is defined
	        by the assertion issuer and the authorization server, and is beyond the scope of this
	        specification.
	      </t>
          <t>
	        The client makes an HTTPS request to the authorization endpoint using POST. The request
	        contains the following parameters:

            <list style="hanging">
              <t hangText="assertion_format">
	            <vspace />
	            REQUIRED. The format of the assertion as defined by the authorization server.
	          </t>
              <t hangText="assertion">
	            <vspace />
	            REQUIRED. The assertion.
	          </t>
              <t hangText="scope">
	            <vspace />
	            OPTIONAL. The authorization server MAY define authorization scope values for the
	            client to include.
	          </t>
            </list>
          </t>
          <t>
	        If successful, the authorization server returns an HTTP 200 response code (OK) with the
	        access token in the response body. The response body contains the following parameters:

            <list style="hanging">
              <t hangText="access_token">
	            <vspace />
	            REQUIRED. The Access Token.
	          </t>
              <t hangText="expires">
	            <vspace />
	            OPTIONAL. The lifetime of the Access Token in seconds. For example, 3600 represents
	            one hour.
	          </t>
            </list>
          </t>
          <t>
	        If the assertion is not valid, the authorization server MUST respond with an HTTP 401
	        (Unauthorized) response code. The Client MUST obtain a new valid assertion before
	        retrying the request.
	      </t>
          <t>
	        Authorization servers SHOULD issue access tokens with a limited lifetime and require
	        clients to refresh them by requesting a new access token using the same assertion if it
	        is still valid. Otherwise the client MUST obtain a new valid assertion.
	      </t>
        </section>

      </section>

    </section>

    <section title='Refreshing an Access Token' anchor='refresh_token'>
      <t>
        Authorization servers MAY issue access tokens that expire and thus require clients to
        refresh them. A client determines that an access token needs refreshing either by using the
        access token's expiration information or upon receiving the HTTP 401 Unauthorized response
        when accessing protected resources per <xref target='access_resource' />. A client will
        also refresh a token if it wishes to obtain a corresponding access token secret for use
        when accessing protected resources via signatures (<xref target='using_signatures'/>).
      </t>
      <t>
        Prior to making a request using this flow, the client MUST have obtained a client
        identifier, client secret, and access token request endpoint URI from the
        authorization server.
      </t>
      <t>
        The client constructs an HTTP 'POST' request to the access token request endpoint and
        includes the following REQUIRED parameters:

        <list style='hanging' hangIndent='6'>
          <t hangText='mode'>
	        <vspace />
            The parameter value MUST be set to 'refresh_token' (case sensitive).
          </t>
          <t hangText='client_id'>
	        <vspace />
            The client identifier.
          </t>
          <t hangText='refresh_token'>
	        <vspace />
            The refresh token associated with the access token to be refreshed.
          </t>
        </list>
      </t>
      <t>
        If the client has access to the client secret, the following parameter SHOULD also be added
        to the request:

        <list style='hanging' hangIndent='6'>
          <t hangText='client_secret'>
	        <vspace />
            The client secret.
          </t>
        </list>
      </t>
      <t>
        If the client wishes to obtain an access token for use when accessing protected resources
        via signatures, the following parameters MUST also be added to the request:

        <list style='hanging' hangIndent='6'>
          <t hangText='want_secret'>
	        <vspace />
            The parameter value MUST be set to 'true' (case sensitive).
          </t>
        </list>
      </t>
      <t>
        Since the request results in the transmission of plain text credentials in both the HTTP
        request and response, the authorization server MUST require the use of a transport-layer
        mechanism such as TLS or SSL (or a secure channel with equivalent protections).
      </t>
      <figure>
        <preamble>
          For example, the client makes the following HTTPS request:
        </preamble>
        <artwork>
          <![CDATA[
  POST /refresh_token HTTP/1.1
  Host: server.example.com
  
  client_id=s6BhdRkqt3&client_secret=8eSEIpnqmM&refresh_token=n4E9O119d
]]>
        </artwork>
      </figure>
      <t>
        The authorization server MUST verify that the resource owner has still authorized the
        provisioning of an access token to the client and that the refresh token is valid. If the
        request is authorized, the access token is included in the HTTP response body using the
        'application/x-www-form-urlencoded' content type as defined by
        <xref target='W3C.REC-html40-19980424' /> with a 200 status code (OK).
      </t>
      <t>
        If an access token secret is included in the response, the protected resource MUST NOT
        allow the use of the corresponding access token without its secret
        (<xref target='using_ssl' />).
      </t>
      <t>
        The response contains the following REQUIRED parameters:

        <list style='hanging' hangIndent='6'>
          <t hangText='access_token'>
	        <vspace />
            The access token.
          </t>
        </list>
      </t>
      <t>
        The authorization server MAY also include the following parameters:

        <list style='hanging' hangIndent='6'>
          <t hangText='expires'>
	        <vspace />
            The lifetime of the access token in seconds.
          </t>
          <t hangText='access_token_secret'>
	        <vspace />
            A corresponding access token secret if the client requested one.
          </t>
          <t hangText='signature_methods'>
	        <vspace />
            A comma-separated list of signature methods supported by the protected resource,
            ordered by preference. REQUIRED if an access token secret is being returned. Possible
            values include 'HMAC-SHA1' and 'HMAC-SHA256' (case-sensitive) as well as any other
            values defined by extensions to this protocol.
          </t>
        </list>
      </t>
      <figure>
        <preamble>
          For example (line breaks are for display purposes only):
        </preamble>
        <artwork>
          <![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/x-www-form-urlencoded

  access_token=8F44J2HGMl
]]>
        </artwork>
      </figure>
      <figure>
        <artwork>
          <![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/x-www-form-urlencoded

  access_token=8F44J2HGMl&access_token_secret=h3B2Tw1CHw&signature_meth
  ods=HMAC-SHA1,HMAC-SHA256
]]>
        </artwork>
      </figure>
      <t>
        If the request fails verification, the authorization server SHOULD respond with the
        appropriate HTTP response status code. The authorization server MAY include further details
        about why the request was rejected in the response body.
      </t>
      <figure>
        <preamble>
          For example:
        </preamble>
        <artwork>
          <![CDATA[
  HTTP/1.1 401 Authorization Required
  WWW-Authenticate: OAuth realm='example'
]]>
        </artwork>
      </figure>
    </section>

    <section title='Accessing a Protected Resource' anchor='access_resource'>
      <t>
        OAuth 2.0 supports the ability for clients to make protected resource requests by using
        TLS/SSL (<xref target='using_ssl' />) and/or by signing their HTTP request with shared
        secrets (<xref target='using_signatures' />). Protected resources MUST support clients
        making authenticated requests via TLS/SSL (<xref target='using_ssl' />). Protected
        resources MAY also choose to also support signatures (<xref target='using_signatures' />),
        and it is RECOMMENDED that clients make signature-based authenticated requests via TLS/SSL.
      </t>
      <t>
        If a client includes more than one access token within the request, the protected resource
        MUST respond with a HTTP 400 'Bad Request' error code.
      </t>

      <section title='Bearer Token Requests' anchor='using_ssl'>
        <t>
          When using TLS/SSL, clients MUST present an access token to authenticate to a protected
          resource. Use of the HTTP 'Authorization' header field as defined by
          <xref target='RFC2617' /> is RECOMMENDED, since HTTP implementations are aware that this
          header has special security properties and may require special treatment in caches and
          logs. Protected resources SHOULD take precautions to ensure that access tokens are not
          inadvertently logged or captured. It is RECOMMENDED that clients verify the authenticity
          of the certificate provided when establishing a TLS/SSL connection to the protected
          resource.
        </t>

        <section title='HTTP Header'>
          <t>
            The protected resource SHOULD allow clients to make authenticated requests by including
            the access token in the HTTP 'Authorization' header. Prior to making a request, the
            client MUST have obtained a valid access token and the API request endpoint URI.
          </t>
          <t>
            The client constructs a HTTP request to the API request endpoint URI and includes the
            HTTP 'Authorization' header field with the auth-scheme name set to 'OAuth'
            (case-insensitive).
          </t>
          <t>
            Since the request results in the transmission of plain text credentials in the HTTP
            request, the protected resource MUST require the use of a transport-layer mechanism
            such as TLS or SSL (or a secure channel with equivalent protections).
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request:
            </preamble>
            <artwork>
              <![CDATA[
  GET /user/daveman692.json HTTP/1.1
  Host: api.example.com
  Authorization: OAuth access_token='vF9dft4qmT'
]]>
            </artwork>
          </figure>
          <figure>
            <preamble>
              Note that per <xref target='RFC2617' /> section 1.2 the following request is also
              valid:
            </preamble>
            <artwork>
              <![CDATA[
  GET /user/daveman692.json HTTP/1.1
  Host: api.example.com
  Authorization:  OAuth  access_token = vF9dft4qmT
]]>
            </artwork>
          </figure>
          <t>
            If the request fails verification, the protected resource SHOULD respond with the
            appropriate HTTP response status code. The protected resource MAY include further
            details about why the request was rejected in the response body or headers.
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork>
              <![CDATA[
  HTTP/1.1 401 Authorization Required
  WWW-Authenticate: OAuth realm='https://api.example.com/'
]]>
            </artwork>
          </figure>
        </section>

        <section title='URI Query Parameter'>
          <t>
            The protected resource MAY allow clients to make authenticated requests by including
            the access token as a URI query parameter. Prior to making a request, the client MUST
            have obtained a valid access token and the API request endpoint URI. While the
            following examples use the HTTP 'GET' method, there's nothing limiting a client to
            use query parameters with other HTTP methods.
          </t>
          <t>
            The client constructs the request URI by adding the following REQUIRED query parameter
            to the API request endpoint:

            <list style='hanging' hangIndent='6'>
              <t hangText='access_token'>
  	           <vspace />
                The access token.
              </t>
            </list>
          </t>
          <t>
            Since the request results in the transmission of plain text credentials in the HTTP
            request, the protected resource MUST require the use of a transport-layer mechanism
            such as TLS or SSL (or a secure channel with equivalent protections).
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request:
            </preamble>
            <artwork>
              <![CDATA[
  GET /user/daveman692.json?access_token=vF9dft4qmT HTTP/1.1
  Host: api.example.com
]]>
            </artwork>
          </figure>
          <t>
            If the request fails verification, the protected resource SHOULD respond with the
            appropriate HTTP response status code. The protected resource MAY include further
            details about why the request was rejected in the response body.
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork>
              <![CDATA[
  HTTP/1.1 401 Authorization Required
  WWW-Authenticate: OAuth realm='https://api.example.com/'
]]>
            </artwork>
          </figure>
        </section>

        <section title='Form-Encoded Body Parameter'>
          <t>
            The protected resource MAY allow clients to make authenticated requests by including
            the access token as a parameter in the body of a HTTP request. Prior to making a
            request, the client MUST have obtained a valid access token and the API request
            endpoint URI.
          </t>
          <t>
            The client constructs an HTTP 'POST', 'PUT', or 'DELETE' request to the API request
            endpoint and includes the following REQUIRED parameter:

            <list style='hanging' hangIndent='6'>
              <t hangText='access_token'>
	            <vspace />
                The access token.
              </t>
            </list>
          </t>
          <t>
            Since the request results in the transmission of plain text credentials in the HTTP
            request, the protected resource MUST require the use of a transport-layer mechanism
            such as TLS or SSL (or a secure channel with equivalent protections).
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request:
            </preamble>
            <artwork>
              <![CDATA[
  POST /blog/entry HTTP/1.1
  Host: api.example.com
  
  access_token=vF9dft4qmT
]]>
            </artwork>
          </figure>
          <t>
            If the request fails verification, the protected resource SHOULD respond with the
            appropriate HTTP response status code. The protected resource MAY include further
            details about why the request was rejected in the response body.
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork>
              <![CDATA[
  HTTP/1.1 401 Authorization Required
  WWW-Authenticate: OAuth realm='https://api.example.com/'
]]>
            </artwork>
          </figure>
        </section>

      </section>

      <section title='Signed Requests' anchor='using_signatures'>
        <t>
          When using signatures, clients MAY use TLS/SSL as the transport to authenticate to a
          protected resource.
        </t>
        <t>
          The following parameters are obtained (or computed) by clients in order to make protected
          resource requests:

          <list style='hanging' hangIndent='6'>
            <t hangText='access_token'>
              <vspace />
              The access token obtained through a refresh token call with the 'want_secret'
              parameter included (<xref target='refresh_token'/>).
            </t>
            <t hangText='signature_method'>
              <vspace />
              The signature method used by the client to sign the request. The method MUST be one
              of those listed in the 'signature_methods' parameter returned with the access
              token secret (<xref target='refresh_token' />).
            </t>
            <t hangText='timestamp'>
              <vspace />
              Unless otherwise specified by the server's documentation, the timestamp is expressed in
              the number of seconds since January 1, 1970 00:00:00 GMT. It MUST be a positive integer.
            </t>
            <t hangText='nonce'>
              <vspace />
              A nonce is a random string, uniquely generated by the client to allow the server to
              verify that a request has never been made before and helps prevent replay attacks when
              requests are made over a non-secure channel. The nonce value MUST be unique across all
              requests with the same timestamp and token combinations.
            </t>
            <t hangText='signature'>
              <vspace />
              The computed signature value ensuring the integrity of this request
              (<xref target='compute_sig' />).
            </t>
          </list>
        </t>
        <t>
          The protocol parameters are added to the request using the
          <xref target='sig_headers'>HTTP Header</xref>.
        </t>
        <t>
          Construction of the signature base string follows the process detailed in section 3.4.1
          of <xref target='I-D.hammer-oauth' />.
        </t>
        <figure>
          <preamble>
            For example the request:
          </preamble>
          <artwork>
            <![CDATA[
  GET /user/daveman692.json?b5=%3D%25%3D&a3=a&c%40=&a2=r%20b HTTP/1.1
  Host: api.example.com
  Content-Type: application/x-www-form-urlencoded
  Authorization: OAuth
                 access_token='vF9dft4qmT',
                 signature_method='HMAC-SHA1',
                 timestamp='1268998408',
                 nonce='7d8f3e4a',

  c2&a3=2+q
]]>
          </artwork>
        </figure>
        <figure>
          <preamble>
            Is represented by the following signature base string (line breaks are for display
            purposes only):
          </preamble>
          <artwork>
            <![CDATA[
  GET&amp;http%3A%2F%2Fapi.example.com%2Fuser%2Fdaveman692.json&amp;a2%
  3Dr%2520b%26a3%3D2%252Bq%26a3%3Da%26b5%3D%253D%2525%253D%26c%2540%3D%
  26c2%3D%26nonce%3D7d8f3e4a%26signature_method%3DHMAC-SHA1%26timestamp
  %3D1268998408%26access_token%3DvF9dft4qmT%26version%3D2.0
]]>
          </artwork>
        </figure>

        <section title='Computing the signature' anchor='compute_sig'>
          <t>
            The authorization server declares which signature methods it accepts via the
            'signature_methods' returned as part of obtaining an access token secret
            (<xref target='refresh_token' />). The client declares which signature method is used
            for this request via the 'signature_method' parameter. It then generates a
            signature, and includes it in the 'signature' parameter. The server verifies the
            signature as specified for each method.
          </t>
          <t>
            There is no mandate for a particular signature method as each implementation can have
            its own unique requirements. Authorization servers are free to implement and document
            their own custom methods.
          </t>

          <section title='HMAC-SHA1'>
            <t>
              The 'HMAC-SHA1' signature method uses the HMAC-SHA1 signature algorithm as defined in
              <xref target='RFC2104' />:

              <list>
                <t>
                  digest = HMAC-SHA1 (key, text)
                </t>
              </list>
            </t>
            <t>
              The HMAC-SHA1 function variables are used in following way:

              <list style='hanging' hangIndent='6'>
                <t hangText='text'>
                  is set to the value of the signature base string.
                </t>
                <t hangText='key'>
                  is set to the access token secret.
                </t>
                <t hangText='digest'>
                  is used to set the value of the 'signature' protocol parameter, after the
                  result octet string is base64-encoded per section 6.8 of <xref target='RFC2045' />.
                </t>
              </list>
            </t>
          </section>

        </section>

        <section title='Client Calls Protected Resource Using HTTP Headers' anchor='sig_headers'>
          <t>
            The protected resource MAY allow clients to make authenticated requests by including
            the access token in the HTTP 'Authorization' header. Prior to making a request, the
            client MUST have obtained a valid access token, a valid access token secret, and the
            API request endpoint URI. It MUST have also constructed the signature base string and
            <xref target='compute_sig'>computed the signature</xref>.
          </t>
          <t>
            The client constructs a HTTP request to the API request endpoint URI and includes the
            HTTP 'Authorization' header field with the auth-scheme name set to 'OAuth'
            (case-insensitive). The protocol parameters and the signature computed in
            <xref target='compute_sig' /> are included in the Authorization header.
          </t>
          <figure>
            <preamble>
              For example, a valid request follows the form of:
            </preamble>
            <artwork>
              <![CDATA[
  GET /user/daveman692.json?b5=%3D%25%3D&a3=a&c%40=&a2=r%20b HTTP/1.1
  Host: api.example.com
  Content-Type: application/x-www-form-urlencoded
  Authorization: OAuth
                 access_token='vF9dft4qmT',
                 signature_method='HMAC-SHA1',
                 timestamp='1268998408',
                 nonce='7d8f3e4a',
                 signature='hfVFpKvoKp5S6YaNIJ6ljuNYR6s%3D'

  c2&a3=2+q
]]>
            </artwork>
          </figure>
          <t>
            If the request fails verification, the protected resource SHOULD respond with the
            appropriate HTTP response status code. The protected resource MAY include further
            details about why the request was rejected in the response body or headers.
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork>
              <![CDATA[
  HTTP/1.1 401 Authorization Required
  WWW-Authenticate: OAuth realm='Exmaple'
]]>
            </artwork>
          </figure>
        </section>

      </section>

    </section>

    <section title="The WWW-Authenticate Response Header" anchor="authn_header">
      <t>
        A server receiving a request for a protected resource without a valid
        <xref target="authz_header">Authorization header field</xref> MUST respond with a 401
        status code (Unauthorized), and includes at least one
        <spanx style="verb">WWW-Authenticate</spanx> header field including a token scheme
        challenge.
      </t>
      <t>
        The <spanx style="verb">WWW-Authenticate</spanx> header field uses the framework defined by
        <xref target="RFC2617" /> as follows:
      </t>
      <figure>
        <artwork xml:space="preserve"><![CDATA[
 challenge       = "Token" RWS token-challenge
   
 token-challenge = realm
                   [ CS authz-uri ]
                   [ CS timestamp ]

 authz-uri       = "authorization-uri" "=" URI-Reference
 timestamp       = "timestamp" "=" <"> 1*DIGIT <">
 
 CS              = OWF "," OWF
]]>
        </artwork>
      </figure>

      <section title="The 'realm' Attribute">
        <t>
        </t>
      </section>

      <section title="The 'authorization-uri' Attribute" anchor='authz_uri_attribute'>
        <t>
        </t>
      </section>

      <section title="The 'timestamp' Attribute">
        <t>
          Signature-based and hash-based authentication methods use timestamps in combination with
          unique nonce values to protect against replay attacks when used over an insecure channel.
        </t>
        <t>
          The timestamp attribute is used by the server to publish its current time, enabling
          clients to synchronize their close with the server. The timestamp value is the current
          time expressed in the number of seconds since January 1, 1970 00:00:00 GMT, and MUST be a
          positive integer.
        </t>
        <t>
          To avoid the need to retain an infinite number of nonce values for future checks, servers
          MAY choose to restrict the time period after which a request with an old timestamp is
          rejected. Servers applying such a restriction SHOULD provide their current time to the
          client either in every challenge or when a request fails due to a timestamp outside the
          allowed window.
        </t>
      </section>

    </section>

    <section title="The Authorization Request Header" anchor="authz_header">
      <t>
        A client making a request for a protected resource either directly, or in retrying a
        request after receiving a 401 status code (Unauthorized) with a token challenge, MUST
        include at least one <spanx style="verb">Authorization</spanx> header field including
        token scheme credentials.
      </t>
      <t>
        The <spanx style="verb">Authorization</spanx> header field uses the framework defined by
        <xref target="RFC2617" /> as follows:
      </t>
      <figure>
        <artwork xml:space="preserve"><![CDATA[
 credentials    = "Token" RWS token-response
   
 token-response = token-id
                  [ CS nonce ]
                  [ CS timestamp ]
                  [ CS auth ]

 token-id         = "token" "=" <"> token <">
 nonce            = "nonce" "=" <"> token <">
 auth             = "signature" "=" <"> token <">
]]>
        </artwork>
      </figure>

      <section title="The 'token' Attribute">
        <t>
          The value used to identify the set of token credentials used by the client to
          authenticate. The token identifier can be an opaque string or use a well-defined internal
          structure.
        </t>
      </section>

      <section title="The 'nonce' Attribute">
        <t>
          A random string, uniquely generated by the client to allow the server to verify that a
          request has never been made before and helps prevent replay attacks when requests are
          made over a non-secure channel. The nonce value MUST be unique across all requests with
          the same timestamp and token combinations.
        </t>
      </section>

      <section title="The 'timestamp' Attribute">
        <t>
          The timestamp value is the current time expressed in the number of seconds since
          January 1, 1970 00:00:00 GMT, and MUST be a positive integer.
        </t>
      </section>

      <section title="The 'signature' Attribute">
        <t>
          The output of the authentication method function after applying it to the selected
          coverage.
        </t>
      </section>

    </section>

    <section title='Security Considerations'>
      <t>
        [[ Todo ]]
      </t>
    </section>

    <section title='IANA Considerations'>
      <t>
        [[ Not Yet ]]
      </t>
    </section>

    <section title='Acknowledgements'>
      <t>
        [[ Add OAuth 1.0a authors + WG contributors ]]
      </t>
    </section>

    <appendix title='Differences from OAuth 1.0a'>
      <t>
      </t>
    </appendix>

    <appendix title='Document History'>
      <t>
        [[ to be removed by RFC editor before publication as an RFC ]]
      </t>
      <t>
        -00

        <list style='symbols'>
          <t>
            Initial draft based on a combination of WRAP and OAuth 1.0a.
          </t>
        </list>
      </t>
    </appendix>

  </middle>

  <back>

    <references title='Normative References'>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html40-19980424.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml' ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p1-messaging-09.xml"?>

    </references>

    <references title='Informative References'>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-hammer-oauth-10.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-hardt-oauth-01.xml' ?>

    </references>

  </back>

</rfc>
